/**
 * Chat Service
 * 
 * Service layer for secure multi-agent chat functionality
 * using Firebase Cloud Functions
 */

import { getFunctions, httpsCallable } from 'firebase/functions';
import type { ChatMessage, ChatResponse, PatientExtraction } from '../../types';

/**
 * Send message to AI and get structured response
 */
export async function sendMessage(
    message: string,
    conversationHistory: ChatMessage[]
): Promise<ChatResponse> {
    try {
        const functions = getFunctions(undefined, 'us-central1');
        const handleChatSession = httpsCallable<
            { message: string; conversationHistory: ChatMessage[] },
            ChatResponse
        >(functions, 'handleChatSession');

        const result = await handleChatSession({
            message,
            conversationHistory
        });

        return result.data;
    } catch (error) {
        console.error('Error calling chat function:', error);
        throw new Error('Failed to get AI response. Please try again.');
    }
}

/**
 * Generate professional referral summary for WhatsApp
 */
export function generateReferralSummary(
    patientName: string,
    extraction: PatientExtraction,
    conversationHistory: ChatMessage[]
): string {
    const timestamp = new Date().toLocaleString('en-IN', {
        dateStyle: 'medium',
        timeStyle: 'short'
    });

    // Build HPI from conversation
    const userMessages = conversationHistory
        .filter(msg => msg.sender === 'user')
        .map(msg => msg.message)
        .join(' ');

    const hpi = userMessages.substring(0, 300) + (userMessages.length > 300 ? '...' : '');

    // Format vital signs
    const vitalsText = [];
    if (extraction.vitals.temperature) {
        vitalsText.push(`Temp: ${extraction.vitals.temperature}¬∞F`);
    }
    if (extraction.vitals.bloodPressure) {
        vitalsText.push(`BP: ${extraction.vitals.bloodPressure}`);
    }
    if (extraction.vitals.heartRate) {
        vitalsText.push(`HR: ${extraction.vitals.heartRate} bpm`);
    }

    // Build referral summary
    const summary = `üè• *PATIENT REFERRAL - CareLinks*

üìã *Patient:* ${patientName || 'Not specified'}
üìÖ *Date:* ${timestamp}
‚ö†Ô∏è *Risk Level:* ${extraction.riskLevel.toUpperCase()}

*CHIEF COMPLAINT:*
${extraction.symptoms.length > 0 ? extraction.symptoms.join(', ') : 'Not specified'}

*HISTORY OF PRESENT ILLNESS:*
${hpi || 'Patient interview in progress'}

*VITAL SIGNS:*
${vitalsText.length > 0 ? vitalsText.join(' | ') : 'Not recorded'}

${extraction.redFlags.length > 0 ? `üö® *RED FLAGS:*
${extraction.redFlags.map((flag: string) => `‚Ä¢ ${flag}`).join('\n')}

` : ''}*ASSESSMENT:*
Based on clinical interview, patient presents with ${extraction.riskLevel} risk level. ${extraction.riskLevel === 'critical' || extraction.riskLevel === 'high' ? 'Immediate medical evaluation recommended.' : 'Continued monitoring advised.'}

*RECOMMENDATION:*
${extraction.riskLevel === 'critical' ? '‚ö†Ô∏è URGENT: Immediate physician evaluation required' : extraction.riskLevel === 'high' ? 'Schedule appointment within 24 hours' : 'Routine follow-up as needed'}

---
_Generated by CareLinks AI Assistant_
_Community Health Worker: [Your Name]_`;

    return summary;
}

/**
 * Generate WhatsApp deep link with referral summary
 */
export function generateWhatsAppLink(referralSummary: string, phoneNumber?: string): string {
    const encodedMessage = encodeURIComponent(referralSummary);

    if (phoneNumber) {
        // Send to specific number (format: country code + number, e.g., 919876543210)
        return `https://wa.me/${phoneNumber}?text=${encodedMessage}`;
    } else {
        // Open WhatsApp with message, user selects contact
        return `https://wa.me/?text=${encodedMessage}`;
    }
}

/**
 * Partial JSON parser for streaming responses
 * Attempts to extract valid JSON even from incomplete responses
 */
export function parsePartialJSON(text: string): Partial<PatientExtraction> | null {
    try {
        // Try to extract JSON block
        const jsonMatch = text.match(/```json\s*([\s\S]*?)```/);
        if (!jsonMatch) {
            // Try to find incomplete JSON block
            const incompleteMatch = text.match(/```json\s*([\s\S]*)/);
            if (!incompleteMatch) return null;

            // Attempt to close incomplete JSON
            let jsonText = incompleteMatch[1].trim();

            // Count braces to determine how to close
            const openBraces = (jsonText.match(/{/g) || []).length;
            const closeBraces = (jsonText.match(/}/g) || []).length;
            const missingBraces = openBraces - closeBraces;

            if (missingBraces > 0) {
                jsonText += '}'.repeat(missingBraces);
            }

            return JSON.parse(jsonText);
        }

        return JSON.parse(jsonMatch[1]);
    } catch (error) {
        // Return null if parsing fails
        return null;
    }
}
